import { NextRequest, NextResponse } from 'next/server'
import { geminiService } from '@/services/gemini'
import { createAdminClient } from '@/lib/supabase-server'
import type { EveningMessageData, DailyTaskSummary } from '@/types'

// Force dynamic rendering to prevent build-time execution
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

// GET /api/ai/evening-message - Generate evening summary for all users
export async function GET(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    
    // Get today's date
    const today = new Date().toISOString().split('T')[0]
    
    // Get all users
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('*')

    if (usersError || !users) {
      return NextResponse.json(
        { success: false, error: 'Failed to fetch users' },
        { status: 500 }
      )
    }

    // Get daily summary for all users
    const userSummaries: DailyTaskSummary[] = []
    let totalTasksAllUsers = 0
    let completedTasksAllUsers = 0

    for (const user of users) {
      // Get user's tasks for today
      const { data: tasks } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', user.id)
        .or(`due_date.is.null,due_date.eq.${today}`)
        .lte('created_at', today + 'T23:59:59')
        .order('created_at', { ascending: false })

      const totalTasks = tasks?.length || 0
      const completedTasks = tasks?.filter(task => task.status === 'done').length || 0
      const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

      userSummaries.push({
        user,
        tasks: tasks || [],
        completed_count: completedTasks,
        total_count: totalTasks,
        completion_rate: completionRate
      })

      // Add to overall totals
      totalTasksAllUsers += totalTasks
      completedTasksAllUsers += completedTasks
    }

    // Calculate overall completion rate
    const overallCompletionRate = totalTasksAllUsers > 0 
      ? Math.round((completedTasksAllUsers / totalTasksAllUsers) * 100) 
      : 0

    // Prepare evening message data
    const eveningData: EveningMessageData = {
      date: today,
      users_summaries: userSummaries,
      overall_completion_rate: overallCompletionRate,
      motivational_message: '', // Will be generated by Gemini
      formatted_message: '' // Will be generated by Gemini
    }

    // Generate evening message with Gemini
    const formattedMessage = await geminiService.formatEveningMessage(eveningData)
    eveningData.formatted_message = formattedMessage
    eveningData.motivational_message = formattedMessage

    return NextResponse.json({
      success: true,
      data: eveningData,
      message: 'Evening message generated successfully'
    })

  } catch (error) {
    console.error('GET /api/ai/evening-message error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// POST /api/ai/evening-message - Generate evening summary for specific date
export async function POST(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    const body = await request.json()
    const targetDate = body.date || new Date().toISOString().split('T')[0]
    
    // Get all users
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('*')

    if (usersError || !users) {
      return NextResponse.json(
        { success: false, error: 'Failed to fetch users' },
        { status: 500 }
      )
    }

    // Get daily summary for all users for the target date
    const userSummaries: DailyTaskSummary[] = []
    let totalTasksAllUsers = 0
    let completedTasksAllUsers = 0

    for (const user of users) {
      // Get user's tasks for the target date
      const { data: tasks } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', user.id)
        .or(`due_date.is.null,due_date.eq.${targetDate}`)
        .lte('created_at', targetDate + 'T23:59:59')
        .order('created_at', { ascending: false })

      const totalTasks = tasks?.length || 0
      const completedTasks = tasks?.filter(task => task.status === 'done').length || 0
      const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

      userSummaries.push({
        user,
        tasks: tasks || [],
        completed_count: completedTasks,
        total_count: totalTasks,
        completion_rate: completionRate
      })

      // Add to overall totals
      totalTasksAllUsers += totalTasks
      completedTasksAllUsers += completedTasks
    }

    // Calculate overall completion rate
    const overallCompletionRate = totalTasksAllUsers > 0 
      ? Math.round((completedTasksAllUsers / totalTasksAllUsers) * 100) 
      : 0

    // Prepare evening message data
    const eveningData: EveningMessageData = {
      date: targetDate,
      users_summaries: userSummaries,
      overall_completion_rate: overallCompletionRate,
      motivational_message: '',
      formatted_message: ''
    }

    // Generate evening message with Gemini
    const formattedMessage = await geminiService.formatEveningMessage(eveningData)
    eveningData.formatted_message = formattedMessage
    eveningData.motivational_message = formattedMessage

    return NextResponse.json({
      success: true,
      data: eveningData,
      message: 'Evening message generated successfully'
    })

  } catch (error) {
    console.error('POST /api/ai/evening-message error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
