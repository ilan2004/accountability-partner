import { NextRequest, NextResponse } from 'next/server'
import { geminiService } from '@/services/gemini'
import { createAdminClient } from '@/lib/supabase-server'
import type { MorningMessageData, DailyTaskSummary } from '@/types'

// GET /api/ai/morning-message - Generate morning message for all users
export async function GET(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    
    // Get today's date
    const today = new Date().toISOString().split('T')[0]
    
    // Get all users
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('*')

    if (usersError || !users) {
      return NextResponse.json(
        { success: false, error: 'Failed to fetch users' },
        { status: 500 }
      )
    }

    // Get daily summary for all users
    const userSummaries: DailyTaskSummary[] = []
    const missingTaskUsers: string[] = []

    for (const user of users) {
      // Get user's tasks for today
      const { data: tasks } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', user.id)
        .or(`due_date.is.null,due_date.eq.${today}`)
        .order('created_at', { ascending: false })

      const totalTasks = tasks?.length || 0
      const completedTasks = tasks?.filter(task => task.status === 'done').length || 0
      const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

      userSummaries.push({
        user,
        tasks: tasks || [],
        completed_count: completedTasks,
        total_count: totalTasks,
        completion_rate: completionRate
      })

      // Check if user has no tasks
      if (totalTasks === 0) {
        missingTaskUsers.push(user.name)
      }
    }

    // Prepare morning message data
    const morningData: MorningMessageData = {
      date: today,
      users_summaries: userSummaries,
      missing_task_users: missingTaskUsers,
      formatted_message: '' // Will be generated by Gemini
    }

    // Generate morning message with Gemini
    const formattedMessage = await geminiService.formatMorningMessage(morningData)
    morningData.formatted_message = formattedMessage

    return NextResponse.json({
      success: true,
      data: {
        ...morningData,
        formatted_message: formattedMessage
      },
      message: 'Morning message generated successfully'
    })

  } catch (error) {
    console.error('GET /api/ai/morning-message error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// POST /api/ai/morning-message - Generate morning message for specific date
export async function POST(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    const body = await request.json()
    const targetDate = body.date || new Date().toISOString().split('T')[0]
    
    // Get all users
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('*')

    if (usersError || !users) {
      return NextResponse.json(
        { success: false, error: 'Failed to fetch users' },
        { status: 500 }
      )
    }

    // Get daily summary for all users for the target date
    const userSummaries: DailyTaskSummary[] = []
    const missingTaskUsers: string[] = []

    for (const user of users) {
      // Get user's tasks for the target date
      const { data: tasks } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', user.id)
        .or(`due_date.is.null,due_date.eq.${targetDate}`)
        .lte('created_at', targetDate + 'T23:59:59')
        .order('created_at', { ascending: false })

      const totalTasks = tasks?.length || 0
      const completedTasks = tasks?.filter(task => task.status === 'done').length || 0
      const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

      userSummaries.push({
        user,
        tasks: tasks || [],
        completed_count: completedTasks,
        total_count: totalTasks,
        completion_rate: completionRate
      })

      // Check if user has no tasks
      if (totalTasks === 0) {
        missingTaskUsers.push(user.name)
      }
    }

    // Prepare morning message data
    const morningData: MorningMessageData = {
      date: targetDate,
      users_summaries: userSummaries,
      missing_task_users: missingTaskUsers,
      formatted_message: ''
    }

    // Generate morning message with Gemini
    const formattedMessage = await geminiService.formatMorningMessage(morningData)
    morningData.formatted_message = formattedMessage

    return NextResponse.json({
      success: true,
      data: morningData,
      message: 'Morning message generated successfully'
    })

  } catch (error) {
    console.error('POST /api/ai/morning-message error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
